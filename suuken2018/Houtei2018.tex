\documentclass[11pt, a4paper, dvipdfmx]{jsarticle}
    \usepackage{amsmath}
    \usepackage{amsthm}
    \usepackage[psamsfonts]{amssymb}
    \usepackage{color}
    \usepackage{ascmac}
    \usepackage{amsfonts}
    \usepackage{mathrsfs}
    \usepackage{amssymb}
    \usepackage{graphicx}
    \usepackage{fancybox}
    \usepackage{enumerate}
    \usepackage{verbatim}
    \usepackage{subfigure}
    \usepackage{proof}
    \usepackage{listings}
    \usepackage{otf}
 %
    \theoremstyle{definition}
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %ここにないパッケージを入れる人は，必ずここに記載すること．
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %ここからはコード表です．
    %
   \newtheorem{Axiom}{公理}[section]
    \newtheorem{Definition}[Axiom]{定義}
    \newtheorem{Theorem}[Axiom]{定理}
    \newtheorem{Proposition}[Axiom]{命題}
    \newtheorem{Lemma}[Axiom]{補題}
    \newtheorem{Corollary}[Axiom]{系}
    \newtheorem{Example}[Axiom]{例}
    \newtheorem{Claim}[Axiom]{主張}
    \newtheorem{Property}[Axiom]{性質}
    \newtheorem{Attention}[Axiom]{注意}
    \newtheorem{Question}[Axiom]{問}
    \newtheorem{Problem}[Axiom]{問題}
    \newtheorem{Consideration}[Axiom]{考察}
    \newtheorem{Alert}[Axiom]{警告}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    %定義や定理等に番号をつけたくない場合（例えば定理1.1等）は以下のコードを使ってください．
    %但し，例えば\Axiom*{}としてしまうと番号が付いてしまうので，必ず　\begin{Axiom*}　\end{Axiom*}の形で使ってください．
    \newtheorem*{Axiom*}{公理}
    \newtheorem*{Definition*}{定義}
    \newtheorem*{Theorem*}{定理}
    \newtheorem*{Proposition*}{命題}
    \newtheorem*{Lemma*}{補題}
    \newtheorem*{Example*}{例}
    \newtheorem*{Corollary*}{系}
    \newtheorem*{Claim*}{主張}
    \newtheorem*{Property*}{性質}
    \newtheorem*{Attention*}{注意}
    \newtheorem*{Question*}{問}
    \newtheorem*{Problem*}{問題}
    \newtheorem*{Consideration*}{考察}
    \newtheorem*{Alert*}{警告}
    \renewcommand{\proofname}{\bfseries Proof}
    
    \newcommand{\A}{\bf 証明}
    \newcommand{\B}{\it Proof}
    
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %英語で定義や定理を書きたい場合こっちのコードを使うこと．
    \newtheorem{Axiom+}{Axiom}[section]
    \newtheorem{Definition+}[Axiom+]{Definition}
    \newtheorem{Theorem+}[Axiom+]{Theorem}
    \newtheorem{Proposition+}[Axiom+]{Proposition}
    \newtheorem{Lemma+}[Axiom+]{Lemma}
    \newtheorem{Example+}[Axiom+]{Example}
    \newtheorem{Corollary+}[Axiom+]{Corollary}
    \newtheorem{Claim+}[Axiom+]{Claim}
    \newtheorem{Property+}[Axiom+]{Property}
    \newtheorem{Attention+}[Axiom+]{Attention}
    \newtheorem{Question+}[Axiom+]{Question}
    \newtheorem{Problem+}[Axiom+]{Problem}
    \newtheorem{Consideration+}[Axiom+]{Consideration}
    \newtheorem{Alert+}{Alert}
    %\renewcommand{\proofname}{\bfseries 証明}
    %
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %数
    \newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\W}{{\cal W}}
\newcommand{\cS}{{\cal S}}
\newcommand{\Wpm}{W^{\pm}}
\newcommand{\Wp}{W^{+}}
\newcommand{\Wm}{W^{-}}
\newcommand{\p}{\partial}
\newcommand{\Dx}{D_{x}}
\newcommand{\Dxi}{D_{\xi}}
\newcommand{\lan}{\langle}
\newcommand{\ran}{\rangle}
\newcommand{\pal}{\parallel}
\newcommand{\dip}{\displaystyle }
\newcommand{\e}{\varepsilon}
\newcommand{\dl}{\delta}
\newcommand{\pphi}{\varphi}
\newcommand{\ti}{\tilde}
    \title{Submodular function maximization and Greedy algorithm}
    \author{yataka}
    %\date{}
\begin{document}
\maketitle
%ソースコードの設定
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}
\section{はじめに}
この方程では$V$は有限集合であるとする.
\section{劣モジュラ関数}
まず劣モジュラ関数を定義する.
\begin{Definition+}(Discreate derivative)\\
    $f$を集合関数とする. $S$を$V$の部分集合とし$e$を$V$の元とする. この時$f$の$S$での
    Discreate derivativeを
    \begin{align*}
        \Delta_{f}(e | S) := f(S\cup\{e\}) - f(S)
    \end{align*}
    と定義する.
\end{Definition+}
\begin{Definition+}(Submodular function)\\
    $f$を集合関数とする. $f$がSubmodular functionであるとは
    \begin{align*}
        \forall A, B\subset V, \forall e\in V,A\subset B かつe\in V - B\Longrightarrow \Delta_{f}(e | A)\geq\Delta_{f}(e | B)
    \end{align*}
    を満たすことをいう.
\end{Definition+}
\begin{Theorem+}$f$を集合関数とする. この時
    \begin{enumerate}
        \item $f$は Submodular function である.
        \item $\forall A, B\subset V, f(A\cap B) + f(A\cup B)\leq f(A) + f(B)$ 
    \end{enumerate}
    は同値である.
    \begin{proof}
        1.$\implies$2.) 任意に$A, B\subset V$をとる. $A - B = \phi$の時, すなわち
        $A\subset B$の時は$A\cap B = A$, $A\cup B = B$より成立するので, $A - B\neq\phi$の時を考える.
        $| A - B| = m$とし$A - B = \{i_{1}, i_{2}, \cdots, i_{m}\}$とすると$A_{0} = A\cap B$, $B_{0} = B$として
        $A_{k}, B_{k} (k\in\{1, 2, \cdots, m\})$を以下のように定義する.
        \begin{align*}
            A_{1} = A_{0}\cup\{i_{1}\}, ~~~~~ A_{2} = A_{0}\cup\{i_{1}, i_{2}\}, \cdots, ~~~~~ A_{m} = A_{0}\cup\{i_{1}, i_{2}, \cdots, i_{m}\}\\
            B_{1} = B_{0}\cup\{i_{1}\}, ~~~~~ B_{2} = B_{0}\cup\{i_{1}, i_{2}\}, \cdots, ~~~~~ B_{m} = B_{0}\cup\{i_{1}, i_{2}, \cdots, i_{m}\}
        \end{align*}
        この時$A_{m} = A$, $B_{m} = A\cup B$である. また,
        \begin{align*}
            \forall k\in\{1, 2, \cdots, m\}, A_{k - 1}\subset B_{k-1}かつA_{k} = A_{k-1}\cup\{i_{k}\}かつB_{k} = B_{k-1}\cup\{i_{k}\}
        \end{align*}
        が成立するので1.より
        \begin{align*}
            \forall k\in\{1, 2, \cdots, m\}, f(A_{k}) - f(A_{k - 1})\geq f(B_{k}) - f(B_{k-1})
        \end{align*}
        が成立する. $k$についてこの不等式の両辺の和をとると, 
        \begin{align*}
            \sum_{k =1}^{m}\left(f(A_{k}) - f(A_{k - 1})\right)\geq\sum_{k =1}^{m}\left(f(B_{k}) - f(B_{k - 1})\right)
        \end{align*}
        両辺を計算すると
        \begin{align*}
            f(A_{m}) - f(A_{0})\geq f(B_{m}) - f(B_{0})
        \end{align*}
        となる. $A, B$は任意なので$A_{m} = A$, $B_{m} = A\cup B$, $B_{0} = B$より
        \begin{align*}
            \forall A, B\subset V, f(A\cap B) + f(A\cup B)\leq f(A) + f(B)
        \end{align*}
        が成立する.\\

        2.$\implies$1.) 任意に$A, B\subset V$と$i\in V - B$を$A\subset B$となるようにとる. $A^{'} = A\cup \{i\}, B^{'} = B$とすると2.より
        \begin{align*}
            f(A^{'}) + f(B^{'})\geq f(A^{'}\cup B^{'}) + f(A^{'}\cap B^{'})
        \end{align*}
        が成立する. ここで$A^{'}\cup B^{'} = B\cup\{i\}$, $A^{'}\cap B^{'} = A$であることから
        \begin{align*}
            f(A^{'}) + f(B^{'})\geq f(B\cup\{i\}) + f(A)
        \end{align*}
        $A^{'}, B^{'}$の定義より
        \begin{align*}
            f(A\cup \{i\}) + f(B)\geq f(B\cup\{i\}) + f(A)
        \end{align*}
        式を整理すると
        \begin{align*}
            f(A\cup \{i\}) - f(A)\geq f(B\cup\{i\}) + f(B)
        \end{align*}
        したがって, $A, B\subset V$と$i\in V - B$は任意だったので,
        \begin{align*}
            \forall A, B\subset V, \forall e\in V,A\subset B かつe\in V - B\Longrightarrow \Delta_{f}(e | A)\geq\Delta_{f}(e | B)
        \end{align*}
        したがって, $f$は Submodular function である.
    \end{proof}
\end{Theorem+}
\begin{Definition+}(Monotone)\\
    $f$を集合関数とする. $f$が Monotone であるとは
    \begin{align*}
        \forall S, T\subset V, S\subset T\Longrightarrow f(S)\leq f(T)
    \end{align*}
    を満たすことを言う.
\end{Definition+}
\begin{Theorem+}
    $f$を集合関数とする.このとき
    \begin{enumerate}
        \item $f$が Monotone である.
        \item $\forall S\subset V, \forall e\in V, \Delta_{f}(e | S)\geq 0$
    \end{enumerate}
    は同値である.
    \begin{proof}
        まあなんか頑張って証明してください.
    \end{proof}
\end{Theorem+}
\begin{Problem+}(読者への演習問題1)\\
    {\bf Theorem 2.5.}を証明せよ.
\end{Problem+}
\begin{Definition+}(Monotone Submodular function)\\
    集合関数$f$が Submodular かつ Monotone であるとき$f$を Monotone Submodular function　と言う.
\end{Definition+}






% まあ, ここまでよくわからない Submodular function というものを定義して来たが, 読者の中には
% 「$V$は有限集合なんだから, $V$の要素を入っているか入っていないかで分けて全通り試せば良い.」 と思う人もいるかもしれない.
% 実際にそれをC++で実装すると以下のようになる.
% \begin{lstlisting}[caption=C++のソースコード,label=ほげ]
% #include<iostream>
% #include<math.h>
% using namespace std;
% #define MAX_N 10
% int main(){
%     int f_V[MAX_N];
%     for(int i = 0;i < MAX_N; i++){
%         if(i % 3 ==0){
%             f_V[i] = -2 * i + 1; 
%         }else{
%             f_V[i] = 2 * i + 1; 
%         }
%     }
%     int sum[1024] = {0};
%     for(int i = 0; i < pow(2, MAX_N); i++){
%         for(int k = 0; k < MAX_N; k++){
%             if(i & 1<<k){
%                 sum[i] += f_V[k];
%             }
%         }
%     }
%     for(int i = 0; i < 1024; i++){
%         cout << sum[i] << " ";
%     }
%     cout << endl;
%     return 0;
% }
%  \end{lstlisting}
%  このコードでは, $|V| = 10$の場合を考えて実装している. このように$|V|$が小さい場合であればこのような方法でも
%  問題はない. しかしながら, $|V| = 10000$の場合はどうだろうか? 調べる候補の数は$2^{10}$から$2^{10000}$へと
%  跳ね上がる. この量を全て調べ上げるのは現実的に不可能である.(100年とか待てるなら別ですが...)\\
%  というわけで, 集合関数$f$が最大となる$V$の部分集合$S$を効率に求めることが必要なのである.




\begin{thebibliography}{10}
    \bibitem{キー1} 劣モジュラ最適化と機械学習・河原 吉伸,  永野 清仁・2015
    \bibitem{キー2} https://las.inf.ethz.ch/files/krause12survey.pdf・Andreas Krause, Daniel Golovin
    \bibitem{キー3} https://www.openu.ac.il/personal\verb|_|sites/moran-feldman/publications/Handbook2018.pdf・Niv Buchbinder, Moran Feldman
    \bibitem{キー4} https://repository.upenn.edu/cgi/viewcontent.cgi?article=2034\verb|&|context=cis\verb|_|reports・Jennifer Gillenwater
  \end{thebibliography}
\end{document}
